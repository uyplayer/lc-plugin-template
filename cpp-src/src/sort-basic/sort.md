
## 排序算法 


-   选择排序所面临的问题
>   `select-sort.cpp`维护左侧已排序区，反复在右侧未排序区中扫描最小值并与当前位置（`current_index`）交换，因此比较次数固定且无法提前结束。
-   拥有稳定性冒泡排序
>   `bubble-sort.cpp`通过相邻元素两两比较完成排序：正向冒泡时外层索引（`current_index`）从右往左收缩，每趟把最大值推到 `current_index` 处，右侧成为已排序区；反向冒泡则让 `current_index` 从左往右扩张，把最小值推到最左端。无论方向如何，只交换相邻元素保证了稳定性，也可在一趟遍历无交换时提前终止。
-   运用逆向思维：插入排序
>   `insertion-sort.cpp` 每次把未排序区的首元素（`current_index`）拿出来，沿着左侧已排序区从右向左比较，遇到更大的元素就后移一步，直到找到恰当位置再插入。这个“局部倒序扫描”的逆向思维让它对小规模或几乎有序的数据非常高效，同时保持相邻元素稳定。
-   突破 O(N^2)：希尔排序
>   `shell-sort.cpp` 先按照递减的 gap 序列把数组分成若干“间隔子序列”，对每个子序列做插入排序；大 gap 阶段能让元素跨越式地移动到接近最终位置，减少后续小 gap（甚至 gap = 1）时的交换次数。得益于这种分组+逐步缩小 gap 的策略，希尔排序在大多数实际输入下可把平均复杂度降到 `O(n log^2 n)` 或更优，虽然仍非稳定算法。
-   妙用二叉树前序位置：快速排序
>   `quick-sort.cpp` 把区间最后一个元素当作 pivot，`partition` 通过一次扫描把“比 pivot 小”和“大于等于 pivot”分到左右两边，并返回 pivot 的最终下标。递归时先处理左子数组再处理右子数组，正好对应二叉树前序遍历“根 -> 左 -> 右”的顺序：根节点是当前区间的 pivot，左、右子节点分别是划分后的区间。得益于这种 Divide & Conquer 结构，平均时间复杂度 `O(n log n)`，但若 pivot 选择不均衡（例如输入已排序）会退化到 `O(n^2)`，可通过随机 pivot 或“三数取中”缓解。
-   妙用二叉树后序位置：归并排序
>   `merge-sort.cpp` 把区间不断二分：`merge_sort` 先递归到左半区，再到右半区，最后才回溯到当前节点执行 `merge`。这个“左 -> 右 -> 根”的顺序就是二叉树后序遍历，体现出“子问题先排好，再在父节点合并”的思想。`merge` 会把左右两个有序子数组复制到缓存，再用两个指针逐个取较小值写回原区间，保证整体有序与稳定。归并排序稳定且始终保持 `O(n log n)` 时间复杂度，但需要 `O(n)` 额外空间。
-   二叉堆结构的运用：堆排序
>   `heap-sort.cpp` 通过把数组视作完全二叉树并构建“最大堆”来工作：`buildMaxHeap` 从最后一个非叶节点开始执行 `siftDown`，确保根节点始终是当前堆的最大值。排序阶段反复把 `a[0]` 与末尾元素交换，把堆容量减一，再对根执行 `siftDown` 恢复堆性质。由于堆是数组原地维护的，整个过程只需 `O(1)` 额外空间，时间复杂度稳定在 `O(n log n)`，但不具备稳定性。如果改用最小堆，则可直接得到降序序列。
-   全新的排序原理：计数排序
>   `counting-sort.cpp` 不再比较元素，而是利用数值范围有限的特性开辟一段计数数组：`count[i]` 表示整数 `i` 出现的次数。遍历原数组统计频次，再按索引从小到大把 `count[i]` 次的值写回原数组，自然得到有序结果。如果存在负数，可用 `minVal` 作偏移让索引非负。计数排序时间复杂度 `O(n + k)`（`k` 为值域大小），对范围小、元素多的整数序列极高效，同时可以轻松扩展成稳定版本。
-   博采众长：桶排序
>   `bucket-sort.cpp` 将输入值域划成若干区间（桶），把元素按值投放到对应桶中，再对每个桶内部排序后顺序拼回：上层调度像计数排序按区间分配，下层可以套任意比较排序（常用插入/快速排序）处理桶内小规模数据。代码中先利用 `minmax_element` 求范围，再按平均桶宽 `(max - min) / n + 1` 创建桶并把元素投进去，随后对每个桶 `sort`，最后汇总回原数组。只要数据在值域上大致均匀，时间复杂度接近 `O(n)`；若分布极不均匀则退化到 `O(n log n)`。
-   基数排序（Radix Sort）
>   `radix-sort.cpp` 通过“按位”多趟排序完成：先找出最大值确定位数，然后从最低位开始，对每一位使用稳定的计数排序（基数 `RADIX=10`）把元素按该位数字分组，再写回原数组；下一轮改看更高一位。靠“低位结果在前、高位稳定叠加”实现整体有序，因此必须保证每一位的计数排序稳定。整段流程对 `d` 位数字需要 `d` 趟计数排序，时间复杂度 `O(d · (n + RADIX))`，适用于固定位长、范围大的非负整数。

### 排序算法的关键指标

-   **时间复杂度**：平均、最坏、最好三种情况决定了算法在不同输入下的理论上限。
-   **空间复杂度**：原地算法（如 `select-sort.cpp`）更节省内存，而 `merge-sort.cpp` 需要额外缓冲。
-   **稳定性**：是否保持相同键值元素的相对次序；`bubble-sort.cpp` 与 `insertion-sort.cpp` 是稳定代表。
-   **实现复杂度与适用场景**：`quick-sort.cpp` 对随机数据高效但需警惕退化，而 `counting-sort.cpp` 要求整数范围有限。



## 排序算法按是否基于元素比较分类

### 比较排序（Comparison-based Sorting）


这些算法通过两两比较元素来决定顺序，平均时间复杂度通常不会优于 `O(n log n)`。

-   选择排序（`select-sort.cpp`）
-   冒泡排序（`bubble-sort.cpp`）
-   插入排序（`insertion-sort.cpp`）
-   希尔排序（`shell-sort.cpp`）
-   快速排序（`quick-sort.cpp`）
-   归并排序（`merge-sort.cpp`）
-   堆排序（`heap-sort.cpp`）


### 非比较排序（Non-comparison Sorting）

利用元素的取值特征或桶/计数结构，不依赖直接比较，因此在特定场景可达到线性时间复杂度。

-   桶排序（`bucket-sort.cpp`）
-   计数排序（`counting-sort.cpp`）
-   基数排序（`radix-sort.cpp`）
