
## 排序算法 


-   选择排序所面临的问题
>   `select-sort.cpp`维护左侧已排序区，反复在右侧未排序区中扫描最小值并与当前位置（`current_index`）交换，因此比较次数固定且无法提前结束。
-   拥有稳定性冒泡排序
>   `bubble-sort.cpp`通过相邻元素两两比较完成排序：正向冒泡时外层索引（`current_index`）从右往左收缩，每趟把最大值推到 `current_index` 处，右侧成为已排序区；反向冒泡则让 `current_index` 从左往右扩张，把最小值推到最左端。无论方向如何，只交换相邻元素保证了稳定性，也可在一趟遍历无交换时提前终止。
-   运用逆向思维：插入排序
>   `insertion-sort.cpp` 每次把未排序区的首元素（`current_index`）拿出来，沿着左侧已排序区从右向左比较，遇到更大的元素就后移一步，直到找到恰当位置再插入。这个“局部倒序扫描”的逆向思维让它对小规模或几乎有序的数据非常高效，同时保持相邻元素稳定。
-   突破 O(N^2)：希尔排序
>   `shell-sort.cpp` 先按照递减的 gap 序列把数组分成若干“间隔子序列”，对每个子序列做插入排序；大 gap 阶段能让元素跨越式地移动到接近最终位置，减少后续小 gap（甚至 gap = 1）时的交换次数。得益于这种分组+逐步缩小 gap 的策略，希尔排序在大多数实际输入下可把平均复杂度降到 `O(n log^2 n)` 或更优，虽然仍非稳定算法。
-   妙用二叉树前序位置：快速排序
-   妙用二叉树后序位置：归并排序
-   二叉堆结构的运用：堆排序
-   全新的排序原理：计数排序
-   博采众长：桶排序
-   基数排序（Radix Sort）

### 排序算法的关键指标

-   **时间复杂度**：平均、最坏、最好三种情况决定了算法在不同输入下的理论上限。
-   **空间复杂度**：原地算法（如 `select-sort.cpp`）更节省内存，而 `merge-sort.cpp` 需要额外缓冲。
-   **稳定性**：是否保持相同键值元素的相对次序；`bubble-sort.cpp` 与 `insertion-sort.cpp` 是稳定代表。
-   **实现复杂度与适用场景**：`quick-sort.cpp` 对随机数据高效但需警惕退化，而 `counting-sort.cpp` 要求整数范围有限。



## 排序算法按是否基于元素比较分类

### 比较排序（Comparison-based Sorting）


这些算法通过两两比较元素来决定顺序，平均时间复杂度通常不会优于 `O(n log n)`。

-   选择排序（`select-sort.cpp`）
-   冒泡排序（`bubble-sort.cpp`）
-   插入排序（`insertion-sort.cpp`）
-   希尔排序（`shell-sort.cpp`）
-   快速排序（`quick-sort.cpp`）
-   归并排序（`merge-sort.cpp`）
-   堆排序（`heap-sort.cpp`）


### 非比较排序（Non-comparison Sorting）

利用元素的取值特征或桶/计数结构，不依赖直接比较，因此在特定场景可达到线性时间复杂度。

-   桶排序（`bucket-sort.cpp`）
-   计数排序（`counting-sort.cpp`）
-   基数排序（`radix-sort.cpp`）
